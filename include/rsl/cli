#pragma once

#include <meta>
#include <cstdio>
#include <print>
#include <ranges>
#include <utility>
#include <vector>
#include <string>
#include <string_view>

#include <print>

#include <rsl/span>
#include <rsl/string_view>
#include <rsl/expect>

// #include "_impl/default_construct.hpp"
#include "_impl/cli/annotations.hpp"
#include "_impl/cli/spec.hpp"

namespace rsl {

class ProgramInfo {
  static std::string& get_name();

public:
  static void set_name(std::string_view arg0);
  static std::string_view name() { return get_name(); }
};

class CLI {
  static void print_help(_cli_impl::Spec const& spec,
                         std::string_view program_name,
                         std::string_view description);

public:
  static constexpr annotations::Option option;
  static constexpr auto value = rsl::placeholders::_0;

  using shorthand   = annotations::Shorthand;
  using description = annotations::Description;

  template <typename T>
  [[= option]] [[noreturn]]
  static void help() {
    constexpr static _cli_impl::Spec spec{remove_cvref(^^T)};
    auto program_name = ProgramInfo::name();
    auto description  = std::string_view{};
    if (auto desc = annotation_of_type<annotations::Description>(^^T); desc) {
      description = desc->data;
    }
    print_help(spec, program_name, description);
    std::exit(0);
  }
};

template <typename T>
T parse_args(std::vector<std::string_view> args_in) {
  static constexpr _cli_impl::Spec spec{^^T};
  auto parser          = _cli_impl::ArgParser{args_in};
  auto& [args, cursor] = parser;

  ProgramInfo::set_name(args[0]);
  cursor = 1;

  auto parsed_args = spec.parse_arguments(parser);
  auto parsed_opts = spec.parse_options(parser);

  _impl::ArgumentTuple<T> args_tuple;
  for (auto argument : parsed_args) {
    argument(&args_tuple);
  }

  for (auto arg : spec.arguments | std::views::drop(parsed_args.size())) {
    if (!arg.is_optional) {
      parser.fail("Missing required argument `{}`", arg.name);
    }
  }

  T object = _impl::default_construct<T>(args_tuple);

  // run options
  for (auto&& option : parsed_opts) {
    option(&object);
  }

  return object;
}
}  // namespace rsl