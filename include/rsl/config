#pragma once

#include <meta>
#include <cstdio>
#include <print>
#include <ranges>
#include <utility>
#include <vector>
#include <string>
#include <string_view>

#include <print>

#include <rsl/span>
#include <rsl/string_view>
#include <rsl/expect>

// #include "_impl/default_construct.hpp"
#include <rsl/cli/annotations.hpp>
#include <rsl/cli/spec.hpp>

namespace rsl {

class ProgramInfo {
  static std::string& get_name();

public:
  static void set_name(std::string_view arg0);
  static std::string_view name() { return get_name(); }
};

class config {
  static std::string& get_config_path();
  static void print_help(_cli_impl::Spec const& spec,
                         std::string_view program_name,
                         std::string_view description);

public:
  static constexpr auto option     = annotations::option;
  static constexpr auto positional = annotations::positional;
  static constexpr auto value      = rsl::placeholders::_0;

  using shorthand   = annotations::Shorthand;
  using description = annotations::Description;

  static std::string_view config_path() { return get_config_path(); }

  template <typename T>
  [[= option]] static void config_path(std::string new_path) {
    get_config_path() = new_path;
  }

  template <typename T>
  [[= option]] [[noreturn]]
  static void help() {
    constexpr static _cli_impl::Spec spec{remove_cvref(^^T)};
    auto program_name = ProgramInfo::name();
    auto description  = std::string_view{};
    if (auto desc = annotation_of_type<annotations::Description>(^^T); desc) {
      description = desc->data;
    }
    print_help(spec, program_name, description);
    std::exit(0);
  }
};

template <typename T>
T load_config(std::vector<std::string_view> args_in) {
  static constexpr _cli_impl::Spec spec{^^T};
  auto parser          = _cli_impl::ArgParser{args_in};
  auto& [args, cursor] = parser;

  ProgramInfo::set_name(args[0]);
  cursor = 1;

  auto parsed_args = spec.parse_arguments(parser);
  auto parsed_opts = spec.parse_options(parser);

  _impl::ArgumentTuple<T> args_tuple;

  auto config = T::config_path();
  std::println("config: {}", config);

  for (auto argument : parsed_args) {
    argument(&args_tuple);
  }

  for (auto arg : spec.arguments | std::views::drop(parsed_args.size())) {
    if (!arg.is_optional) {
      parser.fail("Missing required argument `{}`", arg.name);
    }
  }

  T object = _impl::default_construct<T>(args_tuple);

  // run options
  for (auto&& option : parsed_opts) {
    option(&object);
  }

  return object;
}

template <typename T>
T load_config(int argc, char** argv) {
  return load_config<T>({argv, argv+argc});
}

}  // namespace rsl