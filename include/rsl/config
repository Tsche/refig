#pragma once

#include <meta>
#include <cstdio>
#include <print>
#include <ranges>
#include <utility>
#include <vector>
#include <string>
#include <string_view>

#include <print>

#include <rsl/span>
#include <rsl/string_view>
#include <rsl/expect>

// #include "_impl/default_construct.hpp"
#include <rsl/cli/annotations.hpp>
#include <rsl/cli/spec.hpp>

#include <rsl/json5/json5.hpp>

namespace rsl {

class ProgramInfo {
  static std::string& get_name();

public:
  static void set_name(std::string_view arg0);
  static std::string_view name() { return get_name(); }
};

class config {
  static void print_help(_cli_impl::Spec const& spec,
                         std::string_view program_name,
                         std::string_view description);

public:
  static constexpr auto option = annotations::option;
  static constexpr auto value  = rsl::placeholders::_0;

  using shorthand   = annotations::Shorthand;
  using description = annotations::Description;

  template <typename T>
  [[= option]] [[noreturn]]
  static void help() {
    constexpr static _cli_impl::Spec spec{remove_cvref(^^T)};
    auto program_name = ProgramInfo::name();
    auto description  = std::string_view{};
    if (auto desc = annotation_of_type<annotations::Description>(^^T); desc) {
      description = desc->data;
    }
    print_help(spec, program_name, description);
    std::exit(0);
  }
};

class cli : public config {
  static std::string& get_config_path();

public:
  static constexpr auto option     = annotations::option;
  static constexpr auto positional = annotations::positional;
  static constexpr auto value      = rsl::placeholders::_0;

  using shorthand   = annotations::Shorthand;
  using description = annotations::Description;

  static std::string_view config_path() { return get_config_path(); }

  template <typename T>
  [[= option]] static void config_path(std::string new_path) {
    get_config_path() = new_path;
  }

  template <typename T>
  [[= option]] [[noreturn]]
  static void help() {
    config::template help<T>();
  }
};

template <typename T>
T load_config(std::vector<std::string_view> args_in) {
  static constexpr _cli_impl::Spec spec{^^T};
  auto parser          = _cli_impl::ArgParser{args_in};
  auto& [args, cursor] = parser;

  ProgramInfo::set_name(args[0]);
  cursor = 1;

  auto parsed_args = spec.parse_arguments(parser);
  auto parsed_opts = spec.parse_options(parser);

  _impl::ArgumentTuple<T> args_tuple;

  auto config = json5::load(T::config_path());
  config.template update_argtuple<T>(args_tuple);

  for (auto argument : parsed_args) {
    argument(&args_tuple);
  }

  constexpr auto ctx            = std::meta::access_context::current();
  constexpr static auto members = std::define_static_array(nonstatic_data_members_of(^^T, ctx));
  constexpr auto base_count     = bases_of(^^T, ctx).size();

  template for (constexpr auto Idx : std::views::iota(0zu, members.size())) {
    constexpr static bool has_default = has_default_member_initializer(members[Idx]);
    constexpr static auto name        = std::define_static_string(identifier_of(members[Idx]));

    if (!get<base_count + Idx>(args_tuple).has_value() && !has_default) {
      parser.fail("Missing required argument `{}`", name);
    }
  }

  T object = _impl::default_construct<T>(args_tuple);

  // run options
  for (auto&& option : parsed_opts) {
    option(&object);
  }

  return object;
}

template <typename T>
T load_config(int argc, char** argv) {
  return load_config<T>({argv, argv + argc});
}

}  // namespace rsl